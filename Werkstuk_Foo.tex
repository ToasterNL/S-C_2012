\documentclass[11pt]{article}
\usepackage{a4wide, graphicx, fancyhdr, wrapfig, tabularx, amsmath, amssymb, hyperref, color, verbatim, nameref}
\usepackage{bussproofs}
\usepackage[english]{babel}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour, linkcolor=linkcolour}

%----------------------- Macros and Definitions --------------------------

\setlength\headheight{20pt}\usepackage{}
\addtolength\topmargin{-10pt}
%\addtolength\footskip{20pt}

\fancypagestyle{plain}{%
\fancyhf{}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}

\pagestyle{fancy}
\fancyhf{}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\fancyhead[RO,LE]{\textsc{}}
\fancyhead[LO,RE]{\emph{}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand{\tab}{\hspace*{2em}}

\newcommand{\tocheck}[1]{{\bf !?: #1 :!?}}
\newcommand{\OBA}{Online behavioural advertising }
\newcommand{\oba}{online behavioural advertising }
\newcommand{\ePD}{ePrivacy Directive }
\newcommand{\DPD}{Data Protection Directive }

\frenchspacing

%-------------------------------- Title ----------------------------------

\title{\textbf{Semantiek \& Correctheid \\ \emph{Foo}}}
\author{
	Mark Vijfvinkel, 4077148
	\and Aram Verstegen, 4092368
}
\date{\today}

\begin{document}
\maketitle


\section{Introductie Foo}

Foo is een esoterische taal gebaseerd op `turing-tarpit'-achtige talen zoals `Brainfuck'. Het is in 2008 ontwikkeld door ene ``Feky''.
Taalconstructies in Foo zijn ASCII-strings die een tape met instructies, het programma voor een Foo-machine, voorstellen.
De operaties draaien om een eendimensionale array, de standard input, die genavigeerd en bewerkt kan worden.
Verder zijn er rekenkundige, interne stack- en kopieeroperaties aanwezig.
De standard input gedraagt zich als een tape in de zin dat als er geen standard input wordt gegeven er een lege invoer veronderstelt wordt. 
%De stack wordt voornamelijk gebruikt voor rekenkundige operaties en loops.
Foo maakt dus gebruik van hetzelfde principe als een turingmachine met drie tapes, waarbij \'e\'en van de tapes de standard input bevat, \'e\'en die als stack gebruikt wordt en de laatste die de programmacode bevat. %waar baseren we dit op?
Programma's in Foo stoppen als de interpreter aan het einde van het de programmacode komt (EOF).

\begin{center}
    \begin{tabular}{ | l | p{14cm} | c |}
    \hline
    Teken & Betekenis & ariteit \\ \hline
    " & Alle invoer tussen deze tekens wordt afgedrukt naar stdout. & 1 \\ \hline
    \& & Zet de waarde van de geselecteerde cel in de array om naar een andere waarde. Gevolgd door een numerieke waarde (\&55) levert dit de waarde 55 in de cel. Zonder numerieke waarde wordt er een waarde van de stack gepopped om in de cel te zetten. & 1 of 2\\ \hline
    @ & Vergelijkbaar met '\&' alleen wordt er een waarde op de stack gepusht. & 1 of 2\\ \hline
    \(<\) & Verlaagt de array pointer met \'e\'en. & 0 \\ \hline
    \(>\) & Verhoogt de array pointer met \'e\'en. & 0 \\ \hline
    \$ & Drukt een enkele waarde af. Er zijn drie mogelijkheden: druk af als integer (i), druk af als hexadecimaal integer (h) en als ASCII karakter (c). Als er niet zo een `format string' wordt gespecificeerd wordt er een foutmelding gegeven door de interpreter. & 2 \\ \hline
    +, -, *, /, \% & Rekenkundige operatoren, deze werken zoals we zouden verwachten als respectievelijk optellen, aftrekken, vermenigvuldigen, delen en modulo. Deze operators worden links toegepast op het huidige element in de array met standard input en gebruiken van rechts de numerieke waarde die op de operator volgt. & 2\\ \hline
    \# & Pauzeert de uitvoering van het programma voor een opgegeven aantal seconden. & 1\\ \hline
    ( & Specificeert het begin van een loop: als dit gevolgd wordt door een natuurlijk getal dan wordt deze loop uitgevoerd zolang de waarde in de huidige cel van de array met standard input  ongelijk is aan de opgegeven waarde. Als er geen nummer is opgegeven dan wordt de loop uitgevoerd zolang de waarde die in de cel van de array met standard input staat ongelijk is aan nul. & 0 of 1 \\ \hline
    ) & Specificeert het einde van een loop: er wordt teruggesprongen naar de laatste '(' tenzij de waarde van de huidige cel in de array met standard input gelijk is aan het eerder opgegeven nummer, dan wordt verder gegaan met de rest van code. & 0 \\ \hline
  

    \hline
    \end{tabular}
\end{center}


In het werkstuk van Talen \& Automaten hebben we aangetoond dat Foo een niet-reguliere taal is, maar wel een contextvrije taal.

\section{Interessante constructies in Foo}

Foo bevat, net als de taal While, een beperkte instructieset. 
Foo heeft een aantal constructies die niet voorkomen in While, wat Foo ten opzichte van While interessant maakt.
Een aantal constructies die interessant zijn, zoals de pauzeer (\#) operatie, een standard input/output en operaties op een stack als inherent taalonderdeel, in tegenstelling tot While dat stacks slechts als intern berekeningsmodel gebruikt.
In dit hoofdstuk zullen we deze constructies bespreken.

\subsection{Pauzeer-operatie (\#)}
De pauzeer-operatie in Foo is het beste te vergelijken met een teller die de uitvoering van de rest van het programma het opgegeven aantal seconden uitstelt. 
Dit is terug te zien in het Foo programma van de terugtellende loop: \verb|&10(#1-1$i$c10)"boom!"$c10|.
{\bf \verb|#1|} betekent hier: pauzeer de rest van het programma \'e\'en seconde. 
Pas dan wordt 1 van de huidige celwaarde afgehaald en de nieuwe waarde afgedrukt of, mocht al afgeteld zijn naar nul, komt er de string "boom" op de standard output te staan.
Dit programma is dus een teller opzich.
Zouden we de waarde 10 achter de \#-operator zetten, dan zou het programma tien seconden wachten en in totaal 100 seconden duren.


Dit lijkt in eerste instantie heel erg op de {\bf\verb|<skip>|} functie in While.
Het enige wat verandert is ten opzichte van de vorige state is de tijd.
Om dit te simuleren moeten we de tijd op het moment van uitvoeren van de pauzeer operatie uitlezen, vervolgens de ingestelde tijd laten verlopen en in de nieuwe state de verstreken tijd vertegenwoordigen.
We zouden dit kunnen modeleren met een interne klok die in hele secondes telt, die eigenlijk los staat van de semantiek vande taal.
Gebruikmakend van Structurele Operationele Semantiek zouden we wellicht deze operator een postconditie kunnen laten hebben die een ongebonden variabele (`tijd') gebruikt om de huidige waarde van de klok op te slaan en een variabele (`x') voor het argument, en aan elk (opvolgend) statement de preconditie kunnen stellen dat de waarde van `tijd' met minstens `x' seconden van de klok verschilt.

Omdat in Foo geen parallele operaties mogelijk zijn is het onmogelijk om door deze operator het strikt logisch gedrag van een programma te veranderen.

\subsection{Foutafhandeling} % Verdere uitleg nodig.

Tijdens het gebruik van aritmatische expressies blijkt dat als er geen waarde wordt opgegeven, de eerste waarde van de stack wordt gebruikt. 
Deze waarde wordt dan van de stack gepopped. 
Als er niks op de stack staat wordt er een foutmelding gegenereerd, maar de berekening schijnt als nog te worden uitgevoerd.

\section{Syntax van Foo}
In dit hoofdstuk zullen we de operaties van Foo formeler maken door een syntax opstellen. 
De syntax van Foo ziet er als volgt uit:
\newline

\begin{math}
{\bf S::= ``c" | \&n | @n | < | > | \$f | \#a | (nS) | S_{1}S_{2} }
\newline
\newline
\indent{\bf c::= ASCII-symbolen| \epsilon}
\newline
\indent{\bf a::= n | +a | -a | *a | /a | \%a}
\newline 
\indent{\bf f::= c | i | h}
\newline
\indent{\bf n::= 0..9n | \epsilon}
\end{math}





\section{Natuurlijke semantiek van Foo}
In dit hoofdstuk zullen we de operaties van Foo inzichtelijker maken door semantiek regels op te stellen. 
We zullen hiervoor in eerste instantie gebruik maken van natuurlijke semantiek.
Mocht blijken dat dit te beperkt is, dan zullen we ons richten op structurele operationele semantiek.
Allereerst definieren we de volgende symbolen en functies:
%DE AV FUNCTIE LEEST ALLEEN DE WAARDE VAN DE CEL UIT....MISSCHIEN MOET ER NOG EEN FUNCTIE KOMEN OM DE WAARDE VAN DE CEL OOK TE UPDATEN NA UITVOERING VAN EEN ARIMETSICHE EXPRESSIE EN NOG EEN STACK UPDATE FUNCTIE?
\newline
\newline
\begin{tabular}{ | l | p{12cm} |}
    \hline
    Teken of functie & Betekenis \\ \hline
    \begin{math} \sigma \end{math} &  Dit verwijst naar de cel van de array en begint met de waarde 0. \\ \hline
    \begin{math} AV(\sigma) \end{math} & Deze functie geeft de waarde terug die in de opgegeven cel staat van de array. \\ \hline
    \begin{math} \rho \end{math} &  Dit staat voor het aantal seconden dat het programma moet pauzeren. \\ \hline
    \begin{math} \theta \end{math} &  Dit staat voor de stack. \begin{math}\theta\end{math} (1) staat voor de eerste waarde van de stack. \\ \hline

\end{tabular}
\newline
\newline
\newline
Hieronder beschrijven we de semantiekregels voor Foo:

De compositieregel zorgt ervoor dat twee verschillende statements aan elkaar geschreven kunnen worden en is vergelijkbaar met de compositieregel uit While. 
Bij Foo worden de statements direct aan elkaar geschreven zonder scheidingsteken, zoals de ; bij While.

%COMP-REGEL
\begin{prooftree}
\LeftLabel{$[Comp_{ns}]$:\quad}
\AxiomC{$\langle S_{1}, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow s'(\sigma, AV(\sigma), \rho, \theta)$}
\AxiomC{$\langle S_{2}, s'(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow s''(\sigma, AV(\sigma), \rho, \theta)$}
\BinaryInfC{$\langle S_{1}S_{2}, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s''(\sigma, AV(\sigma), \rho, \theta)$}
\end{prooftree}

De pauzeerregel zoals hieronder staat beschreven is vergelijkbaar met de skipregel uit While. 
Als dit statement wordt uitgevoerd wordt er het opgeven aantal seconden gewacht met de uitvoering van de rest van het programma. 
Het is niet mogelijk iets in de state te veranderen tijdens het pauzeren, waardoor de state na het pauzeren niet veranderd is op de verstreken tijd na.

%#-REGEL, LABEL STAAT ER NIET !!!
\begin{prooftree}
\LeftLabel{$[\#_{ns}]$:\quad}
\AxiomC{$\langle \#, s(\sigma,  AV(\sigma), \rho, \theta) \rangle \rightarrow s(\sigma,  AV(\sigma), \rho, \theta) $}
\end{prooftree}

%LOOP-REGELS:

Het is mogelijk om loops te maken in Foo.
De moeilijkheid wat betreft semantiekregels zit in het gebruiken van de parameter na de ''(" of het niet gebruiken ervan. 
De eerste regel geeft de situatie weer als er wel gebruik gemaakt wordt van de parameter.

%LOOP TT 1
\begin{prooftree}
\LeftLabel{$[Loop_{ns}^{tt^1}]$:\quad}
%\RightLabel{$if \beta_{[n \not= AV(\sigma)]s} = tt$}
\AxiomC{$\langle (S), s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow s'(\sigma, AV(\sigma), \rho, \theta)$}
\AxiomC{$\langle (n-1 S), s'(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow s''(\sigma, AV(\sigma), \rho, \theta)$}
\BinaryInfC{$\langle (nS), s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s''(\sigma, AV(\sigma), \rho, \theta)$}
\end{prooftree}

$if \beta_{[n \not= AV(\sigma)]s} = tt$
\newline
\newline
In de tweede regel wordt geen parameter opgegeven. 
Hierbij wordt de loop uitgevoerd zolang de waarde van de cel ongelijk is aan nul.

%LOOP TT 2 HIER KLOPT IETS NOG NIET HELEMAAL MET LOOP ITERATIE....WORDT HIER 1 VAN DE CEL WAARDE AFGETROKKEN EN WORDT DIE WAARDE GEUPDATE IN DE CEL OF NIET?
\begin{prooftree}
\LeftLabel{$[Loop_{ns}^{tt^2}]$:\quad}
%\RightLabel{$if \beta_{[0 \not= AV(\sigma)]s} = tt$}
\AxiomC{$\langle (S), s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow s'(\sigma, AV(\sigma), \rho, \theta)$}
\AxiomC{$\langle (S), s'(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow s''(\sigma, AV(\sigma), \rho, \theta)$}
\BinaryInfC{$\langle (S), s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s''(\sigma, AV(\sigma), \rho, \theta)$}
\end{prooftree}

$if \beta_{[0 \not= AV(\sigma)]s} = tt$
\newline
\newline
De axioma's voor de loopregels zijn nagenoeg gelijk.
Beide regels stoppen de uitvoering van de loop als de paramater of 0 gelijk aan de waarde in de cel.

%LOOP FF 1
\begin{prooftree}
\LeftLabel{$[Loop_{ns}^{ff}]$:\quad}
\RightLabel{$if \beta_{[n \not= AV(\sigma)]s} = ff$}
\AxiomC{$\langle (nS), s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s(\sigma, AV(\sigma), \rho, \theta)$}
\end{prooftree}

%LOOP FF 2
\begin{prooftree}
\LeftLabel{$[Loop_{ns}^{ff}]$:\quad}
\RightLabel{$if \beta_{[n \not= Av(\sigma)]s} = ff$}
\AxiomC{$\langle (S), s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s(\sigma, AV(\sigma), \rho, \theta)$}
\end{prooftree}

%Aritmetische expressies

Hieronder volgen de semantiekregels voor de aritmetische expressies die gebruikt kunnen worden in Foo.
Ook hier zit een lastig punt met betrekking tot de semantiekregels.
Als er namelijk een waarde wordt opgegeven dan wordt dit uitgevoerd in combinatie met de huidige waarde van de cel.
Als er geen waarde wordt opgegeven wordt er een waarde van de stack gepopped en gebruikt.
Hiervoor moet dus twee aparte regels opgesteld worden. 
Één voor een opgegeven waarde te herkennen aan de ''a" en één voor het gebruik van de stack.

De + regel wordt gebruikt om een opgegeven waarde op te tellen bij de huidige waarde in de cel.
\begin{prooftree}
\AxiomC{$\langle +a, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)+a, \rho, \theta)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\langle +, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)+ \theta(1), \rho, \theta-1)$}
\end{prooftree}

De - regel wordt gebruikt om een opgegeven waarde af te trekken van de huidige waarde in de cel.
\begin{prooftree}
\AxiomC{$\langle -a, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)-a, \rho, \theta)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\langle -, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)- \theta(1), \rho, \theta-1)$}
\end{prooftree}

De * regel wordt gebruikt om een opgegeven waarde te vermenigvuldigen met de huidige waarde in de cel.
\begin{prooftree}
\AxiomC{$\langle *a, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)*a, \rho, \theta)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\langle *, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)*\theta(1), \rho, \theta-1)$}
\end{prooftree}

De / regel wordt gebruikt om de huidige waarde in de cel te delen met de opgegeven waarde.
\begin{prooftree}
\AxiomC{$\langle /a, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)/a, \rho, \theta)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\langle /, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma)/\theta(1), \rho, \theta-1)$}
\end{prooftree}

De \% regel wordt gebruikt om de modulo te bereken van de huidige waarde in de cel met de opgegeven waarde.
\begin{prooftree}
\AxiomC{$\langle \%a, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma) \%a, \rho, \theta)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\langle \%, s(\sigma, AV(\sigma), \rho, \theta) \rangle \rightarrow  s'(\sigma, AV(\sigma) \% \theta(1), \rho, \theta-1)$}
\end{prooftree}


\section{Structurele operationale semantiek van Foo}

%\bibliographystyle{plain} % amsalpha
%\bibliography{}

\end{document}
