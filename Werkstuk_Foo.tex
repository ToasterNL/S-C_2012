\documentclass[11pt]{article}
\usepackage{a4wide, graphicx, fancyhdr, wrapfig, tabularx, amsmath, amssymb, hyperref, color, verbatim, nameref}
\usepackage{bussproofs}
\usepackage[english]{babel}
\definecolor{linkcolour}{rgb}{0,0.2,0.6}
\hypersetup{colorlinks,breaklinks,urlcolor=linkcolour, linkcolor=linkcolour}

%\input{sl1defs}

%----------------------- Macros and Definitions --------------------------

\setlength\headheight{20pt}\usepackage{}
\addtolength\topmargin{-10pt}
%\addtolength\footskip{20pt}

\fancypagestyle{plain}{%
\fancyhf{}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
}

\pagestyle{fancy}
\fancyhf{}
\fancyfoot[RO,LE]{\sffamily\bfseries\thepage}
\fancyhead[RO,LE]{\textsc{}}
\fancyhead[LO,RE]{\emph{}}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{0pt}
\newcommand{\tab}{\hspace*{2em}}

\newcommand{\tocheck}[1]{{\bf !?: #1 :!?}}
\newcommand{\OBA}{Online behavioural advertising }
\newcommand{\oba}{online behavioural advertising }
\newcommand{\ePD}{ePrivacy Directive }
\newcommand{\DPD}{Data Protection Directive }

\frenchspacing

%-------------------------------- Title ----------------------------------

\title{\textbf{Semantiek \& Correctheid \\ \emph{Foo}}}
\author{
	Mark Vijfvinkel, 4077148
	\and Aram Verstegen, 4092368
}
\date{\today}

\begin{document}
\maketitle


\section{Introductie Foo}

Foo is een esoterische taal gebaseerd op `turing-tarpit'-achtige talen zoals `Brainfuck'. Het is in 2008 ontwikkeld door ene ``Feky''.
Taalconstructies in Foo zijn ASCII-strings die een tape met instructies, het programma voor een Foo-machine, voorstellen.
De operaties draaien om een eendimensionale array, de standard input, die genavigeerd en bewerkt kan worden.
Verder zijn er rekenkundige, interne stack- en kopieeroperaties aanwezig.
De standard input gedraagt zich als een tape in de zin dat als er geen standard input wordt gegeven er een lege invoer verondersteld wordt. 
%De stack wordt voornamelijk gebruikt voor rekenkundige operaties en loops.
Foo maakt dus gebruik van hetzelfde principe als een turingmachine met drie tapes, waarbij \'e\'en van de tapes de standard input bevat, \'e\'en die als stack gebruikt wordt en de laatste die de programmacode bevat. %waar baseren we dit op?
Programma's in Foo stoppen als de interpreter aan het einde van de programmacode komt (EOF).

\begin{center}
    \begin{tabular}{ | l | c | p{12cm} | }
    \hline
    Teken                                   & ariteit & Betekenis \\ \hline
    \verb|" "| & 1                          & Alle invoer tussen deze tekens wordt afgedrukt naar standard output. \\ \hline
    \(<\)                                   & 0 & Verlaagt de array pointer met \'e\'en. \\ \hline
    \(>\)                                   & 0 & Verhoogt de array pointer met \'e\'en. \\ \hline
    \&\(n\)                                 & 1 & Zet de gegeven waarde \(n\) (het argument) in de huidige cel in de array met standard input. \\ \hline
    \&                                      & 0 & Pop de laatste stack-waarde en zet deze in de huidige cel in de array met standard input. \\ \hline
    @\(n\)                                  & 1 & Pusht de gegeven waarde \(n\) (het argument) op de stack. \\ \hline
    @                                       & 0 & Pusht de waarde in de huidige cel in de array met standard input op de stack. \\ \hline
    \$i$n$, \$c$n$, \$h$n$                  & 1 & Drukt een enkele waarde af. Er zijn drie mogelijkheden: druk af als integer (i), druk af als hexadecimaal integer (h) en als ASCII karakter (c). Als er niet zo een `format string' wordt gespecificeerd wordt er een foutmelding gegeven door de interpreter. Het argument \(n\) wordt afgedrukt. \\ \hline
    \$i, \$c, \$h                           & 0 & Drukt een enkele waarde af. Er zijn drie mogelijkheden: druk af als integer (i), druk af als hexadecimaal integer (h) en als ASCII karakter (c). Als er niet zo een `format string' wordt gespecificeerd wordt er een foutmelding gegeven door de interpreter. De huidige waarde in de array met standard input wordt afgedrukt. \\ \hline 
    +\(n\), -\(n\), *\(n\), /\(n\), \%\(n\) & 1 & Rekenkundige operatoren, deze werken zoals verwacht, namelijk optellen, aftrekken, vermenigvuldigen, delen en modulo, respectievelijk. Deze operators worden links toegepast op het huidige element in de array met standard input en gebruiken van rechts de numerieke waarde \(n\) (argument) die op de operator volgt. \\ \hline
    +, -, *, /, \%                          & 0 & Rekenkundige operatoren, deze werken zoals verwacht, namelijk optellen, aftrekken, vermenigvuldigen, delen en modulo, respectievelijk. Deze operators worden links toegepast op het huidige element in de array met standard input en gebruiken van rechts de laatste stack-waarde, die hiervoor gepopt wordt. \\ \hline
    \#\(n\)                                 & 1 & Pauzeert de uitvoering van het programma voor een opgegeven \(n\) aantal seconden. \\ \hline %wat gebeurd er als er niks wordt opgegeven
    (\(n\)                                  & 1 & Specificeert het begin van een loop: deze loop wordt uitgevoerd zolang de waarde in de huidige cel van de array met standard input ongelijk is aan de opgegeven waarde \(n\) (het argument). \\ \hline
    (                                       & 0 & Specificeert het begin van een loop: deze loop wordt uitgevoerd zolang de waarde in de huidige cel van de array met standard input ongelijk is aan nul. \\ \hline
    )                                       & 0 & Specificeert het einde van een loop: er wordt teruggesprongen naar de laatste '(' tenzij de waarde van de huidige cel in de array met standard input gelijk is aan het eerder opgegeven nummer, danwel nul afhankelijk van de gekozen loop-opening. Dan wordt verder gegaan met de rest van code. \\ \hline
    \hline
    \end{tabular}
\end{center}


In het werkstuk van Talen \& Automaten hebben we aangetoond dat Foo een niet-reguliere taal is, maar wel een contextvrije taal.

\section{Interessante constructies in Foo}

Foo bevat, net als de taal While, een beperkte instructieset. 
Foo heeft een aantal constructies die niet voorkomen in While, wat Foo ten opzichte van While interessant maakt.
Een aantal constructies die interessant zijn, zoals de pauzeer (\#) operatie, een standard input/output en operaties op de stack, zullen we in dit hoofdstuk bespreken. %als inherent taalonderdeel, in tegenstelling tot While dat stacks slechts als intern berekeningsmodel gebruikt.
%In dit hoofdstuk zullen we deze constructies bespreken.

\subsection{Pauzeer-operatie (\#)}
De pauzeer-operatie in Foo is het beste te vergelijken met een teller die de uitvoering van de rest van het programma het opgegeven aantal seconden uitstelt. 
Dit is terug te zien in het Foo programma van de terugtellende loop: \verb|&10(#1-1$i$c10)"boom!"$c10|.

{\bf \verb|#1|} betekent hier: pauzeer de rest van het programma \'e\'en seconde. 
Pas dan wordt 1 van de huidige celwaarde afgehaald en de nieuwe waarde afgedrukt of, mocht al afgeteld zijn naar nul, komt er de string "boom" op de standard output te staan.
Dit programma is dus een teller opzich.
Zouden we de waarde 10 achter de \#-operator zetten, dan zou het programma tien seconden wachten en in totaal 100 seconden duren.


Dit lijkt in eerste instantie heel erg op de {\bf\verb|<skip>|} functie in While.
Het enige wat veranderd is ten opzichte van de vorige state is de tijd.
Om dit te simuleren moeten we de tijd op het moment van uitvoeren van de pauzeer operatie uitlezen, vervolgens de ingestelde tijd laten verlopen en in de nieuwe state de verstreken tijd vertegenwoordigen.
%We zouden dit kunnen modeleren met een interne klok die in hele secondes telt, die eigenlijk los staat van de semantiek van de taal.
%Gebruikmakend van Structurele Operationele Semantiek zouden we wellicht deze operator een postconditie kunnen laten hebben die een ongebonden variabele (`tijd') gebruikt om de huidige waarde van de klok op te slaan en een variabele (`x') voor het argument, en aan elk (opvolgend) statement de preconditie kunnen stellen dat de waarde van `tijd' met minstens `x' seconden van de klok verschilt.

Omdat in Foo geen parallele operaties mogelijk zijn is het onmogelijk om door deze operator het strikt logisch gedrag van een programma te veranderen.

\subsection{Foutafhandeling} % Verdere uitleg nodig. Hoe hebben we dit getest of blijkt dit uit de spec? en wat is het resultaat.

Tijdens het gebruik van aritmetische expressies blijkt dat als er geen waarde wordt opgegeven, de eerste waarde van de stack wordt gebruikt. 
Deze waarde wordt dan van de stack gepopt. 
Als er niks op de stack staat wordt er een foutmelding gegenereerd, maar de berekening schijnt als nog te worden uitgevoerd.
Door het nagaan van de referentie-implementatie van Foo hebben we geconstateerd dat deze gepopte waarde ongeinitialiseerd is (in tegenstelling tot een ongedefinieerde waarde in de array, die als 0 wordt geinitialiseerd).
Deze lijkt in de regel de waarde 0 te bevatten op ons testplatform, maar dat is niet iets waar de Foo-programmeur op kan rekenen.
We hebben het genereren van de foutmelding meegenomen in onze regels voor het gebruik van stackwaardes.

\section{Syntax van Foo}
In dit hoofdstuk zullen we de operaties van Foo formeler maken door een syntax op te stellen. 
De syntax van Foo ziet er als volgt uit:
\newline

\begin{math}
{\bf S::= \verb|"c"| | \&n | \& | @n | @ | < | > | \$f | \#a | (nS) | (S) | S_{1}S_{2} }
\newline
\newline
\indent{\bf c::= ASCII-symbolen| \epsilon}
\newline
\indent{\bf a::= n | +n | -n | *n | /n | \%n}
\newline 
\indent{\bf f::= c | i | h}
\newline
\indent{\bf n::= 0..9n | \epsilon}
\end{math}





\section{Natuurlijke semantiek van Foo}
In dit hoofdstuk zullen we de operaties van Foo inzichtelijker maken door semantiekregels op te stellen.
We zullen hiervoor gebruik maken van natuurlijke semantiek.
Mocht blijken dat dit te beperkt is, dan zullen we ons richten op structurele operationele semantiek.

\subsection{Transities}
Allereerst defini\"eren we de volgende symbolen en functies:
%DE AV FUNCTIE LEEST ALLEEN DE WAARDE VAN DE CEL UIT....MISSCHIEN MOET ER NOG EEN FUNCTIE KOMEN OM DE WAARDE VAN DE CEL OOK TE UPDATEN NA UITVOERING VAN EEN ARIMETSICHE EXPRESSIE EN NOG EEN STACK UPDATE FUNCTIE?
\newline
\newline
\begin{tabular}{ | l | p{12cm} |}
    \hline
    Teken of functie & Betekenis \\ \hline
    \begin{math} \sigma \end{math} &  Dit symbool verwijst naar de index van de array en wordt geinitialiseerd met de waarde 0. \\ \hline
    \begin{math} AV \end{math} & Dit symbool staat voor de valuatie van de array met standard input. \\ \hline
    \begin{math} \rho \end{math} &  Dit symbool staat voor het aantal seconden dat het programma moet pauzeren alvorens de volgende instructie te evalueren. \\ \hline
    \begin{math} \theta \end{math} & Dit symbool staat voor de stack. \begin{math}\theta[0]\end{math} staat voor de eerste waarde van de stack. \\ \hline
    \begin{math} O \end{math} &  Dit symbool staat voor de stream standard output. Hieraan kunnen waardes worden geconcateneerd. \\ \hline

\end{tabular}
\newline
\newline
\newline

Onze state zal er als volgt uit zien:

\[
(\sigma, AV, \rho, \theta, O)
\]

Onze transitie van states zal er als volgt uit zien:

\begin{prooftree}
\AxiomC{$\langle S,  s \rangle \rightarrow s'$}
\end{prooftree}

Afhankelijk van statement $S$ zullen de waardes in de state veranderen. 
$s'$ bevat dus veranderde waardes van $\sigma, AV, \rho, \theta, O$. 
%In de onderstaande semantiekregels zullen we alleen de veranderde waardes in de state $s'$ opnemen.
%Op deze manier blijft het overzichtelijk wat er precies veranderd in een transitie.
Als het nog niet duidelijk is wat er precies tijdens een transitie veranderd, omdat dit afhankelijk is van nog uit te voeren states, zullen we dit aangeven met alleen $s'$.


\subsection{Semantiekregels}
Hieronder beschrijven we de semantiekregels voor Foo:

De compositieregel zorgt ervoor dat twee verschillende statements aan elkaar geschreven kunnen worden en is vergelijkbaar met de compositieregel uit While. 
Bij Foo worden de statements direct aan elkaar geschreven zonder scheidingsteken, zoals de ; bij While.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

 $[Comp_{ns}]$ 	& 	\AxiomC{$\langle S_{1}, s \rangle \rightarrow s'$}
				\AxiomC{$\langle S_{2}, s' \rangle \rightarrow s''$}
				\BinaryInfC{$\langle S_{1}S_{2}, s \rangle \rightarrow  s''$}
				\DisplayProof

\end{tabular}
\newline

%\end{table}


%\begin{prooftree}
%\LeftLabel{$[Comp_{ns}]$:\quad}
%\AxiomC{$\langle S_{1}, s \rangle \rightarrow s'$}
%\AxiomC{$\langle S_{2}, s' \rangle \rightarrow s''$}
%\BinaryInfC{$\langle S_{1}S_{2}, s \rangle \rightarrow  s''$}
%\end{prooftree}

De $nav^R_{ns}$ regel verhoogt de index voor de huidige cel in de array met \'e\'en.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[nav^R_{ns}]$	&	\AxiomC{$\langle $\textgreater$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma+1, AV, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline
%\end{table}

De $nav^L_{ns}$ regel verlaagt de index voor de huidige cel in de array met \'e\'en.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[nav^L_{ns}]$	&	\AxiomC{$\langle $\textless$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma-1, AV, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline
%\end{table}

De $ass^i_{ns}$ regel zet het argument in de huidige arraycel.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[ass^n_{ns}]$	&	\AxiomC{$\langle $\&$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma, AV[\sigma] \mapsto n, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline

De $ass^s_{ns}$ regel zet een waarde die van de stack gepopt wordt in de huidige arraycel.
Het eerste (index nul) element van de stack wordt gebruikt, en in de volgende state wordt de stack gegeven vanaf het tweede (index \'e\'en).
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{l c r}

	$[ass^s_{ns}]$	&	\AxiomC{$\langle $\&$, (\sigma, AV(\sigma), \rho, \theta, O) \rangle \rightarrow (\sigma, AV(\sigma) \mapsto \theta[0], \rho, \theta[1...], O)$}
		\DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt$

\end{tabular}
\newline
\begin{tabular}[h]{l c r}

	$[ass^s_{ns}]$	&	\AxiomC{$\langle $\&$, (\sigma, AV(\sigma), \rho, \theta, O) \rangle \rightarrow (\sigma, AV, \rho, \theta, O \| $"Stack is empty"$)$}
		\DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == ff $

\end{tabular}
\newline

De $push^n_{ns}$ regel pusht het argument op de stack.
De waarde wordt geconcateneerd met de gegeven stack, zodat deze bovenaan komt te staan, en gepopt kan worden.
\newline
\newline
\begin{tabular}[h]{c c}

$[push^n_{ns}]$	&	\AxiomC{$\langle $@$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma, AV, \rho, n \| \theta, O)$}
				\DisplayProof

\end{tabular}
\newline

De $push^{AV}_{ns}$ regel pusht een waarde uit de huidige array-cel op de stack.
Ook hier wordt de waarde geconcateneerd met de gegeven stack.
\newline
\begin{tabular}[h]{c c}

$[push^{AV}_{ns}]$	&	\AxiomC{$\langle $@$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma, AV, \rho, AV[\sigma] \| \theta, O)$}
					\DisplayProof

\end{tabular}
\newline

%\begin{prooftree}
%\LeftLabel{$[push^{AV}_{ns}]$:\quad}
%\AxiomC{$\langle $@$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma, AV, \rho, AV[\sigma] \| \theta, O)$}
%\end{prooftree}
De pauzeerregel zoals hieronder staat beschreven is vergelijkbaar met de skipregel uit While. 
Als dit statement wordt uitgevoerd wordt er het opgeven aantal seconden gewacht met de uitvoering van de rest van het programma. 
Het is niet mogelijk iets in de state te veranderen tijdens het pauzeren, waardoor de state na het pauzeren niet veranderd is op de verstreken tijd na.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[\#n_{ns}]$	&	\AxiomC{$\langle $\#$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow (\sigma, AV, \rho + n, \theta, O) $}
				\DisplayProof

\end{tabular}
\newline
%\end{table}

%LOOP-REGELS:

Het is mogelijk om loops te maken in Foo.
De moeilijkheid wat betreft semantiekregels zit in het gebruiken van het argument na de ''(" of het niet gebruiken ervan. 
De eerste regel geeft de situatie weer als er wel gebruik gemaakt wordt van het argument.
\newline
\newline
%LOOP TT 1
%\begin{table}[h]
\begin{tabular}[h]{c c c}

$[Loop_{ns}^{tt^1}]$	&	\AxiomC{$\langle $($nS$)$, s \rangle \rightarrow s' $}
					\AxiomC{$\langle $($n-1 S$)$, s' \rangle \rightarrow s''$}
					\BinaryInfC{$\langle $($nS$)$, s \rangle \rightarrow  s''$}
					\DisplayProof								& $if {\cal B} _{[ n \not= AV[\sigma]]s} = tt$

\end{tabular}
\newline
%\end{table}

In de tweede regel wordt geen parameter opgegeven. 
Hierbij wordt de loop uitgevoerd zolang de waarde van de cel ongelijk is aan nul.
\newline
\newline
%LOOP TT 2 HIER KLOPT IETS NOG NIET HELEMAAL MET LOOP ITERATIE....WORDT HIER 1 VAN DE CEL WAARDE AFGETROKKEN EN WORDT DIE WAARDE GEUPDATE IN DE CEL OF NIET?
%\begin{table}[h]
\begin{tabular}[h]{c c c}

$[Loop_{ns}^{tt^2}]$	&	\AxiomC{$\langle $($S$)$, s \rangle \rightarrow s'$}
					\AxiomC{$\langle $($S$)$, s' \rangle \rightarrow s'' $}
					\BinaryInfC{$\langle $($S$)$, s \rangle \rightarrow  s'' $}
					\DisplayProof								& $if {\cal B} _{[0 \not= AV[\sigma]]s} = tt$

\end{tabular}
\newline
%\end{table}

De axioma's voor de loopregels zijn nagenoeg gelijk.
Beide regels stoppen de uitvoering van de loop als de waarde in de cel gelijk is aan het argument of 0, afhankelijk van de gekozen loop-opening.
\newline
\newline
%LOOP FF 1
%\begin{table}[h]
\begin{tabular}[h]{c c c}

$[Loop_{ns}^{ff^1}]$	&	\AxiomC{$\langle $($nS$)$, s \rangle \rightarrow  s $}
					\DisplayProof								& $if {\cal B}_{[n \not= AV[\sigma]]s} = ff$

\end{tabular}
\newline
%\end{table}

%LOOP FF 2

%\begin{table}[h]
\begin{tabular}[h]{c c c}

$[Loop_{ns}^{ff^2}]$	&	\AxiomC{$\langle $($S$)$, s \rangle \rightarrow  s $}
					\DisplayProof								& $if {\cal B}_{[0 \not= Av(\sigma)]s} = ff$

\end{tabular}
\newline
%\end{table}

Een interessant gegeven in Foo is dat de waarde van de huidige cel in de array, waar de loop invariant check van gebruik maakt, te wijzigen is binnen de loop.
De invariant-waarde waartegen vergeleken wordt (0 of een argument) is echter niet meer te wijzigen na het binnengaan van de loop.


%Aritmetische expressies

Hieronder volgen de semantiekregels voor de aritmetische expressies die gebruikt kunnen worden in Foo.
Ook hier zit een lastig punt met betrekking tot de semantiekregels.
Als er namelijk een waarde wordt opgegeven dan wordt dit uitgevoerd in combinatie met de huidige waarde van de cel.
Als er geen waarde wordt opgegeven wordt er een waarde van de stack gepopt en gebruikt.
Voor al deze gevallen moeten twee aparte regels opgesteld worden. 
\'E\'en om een opgegeven waarde te herkennen in het argument en \'e\'en voor het gebruik van de stack.
\newline

De $+^n_{ns}$ regel wordt gebruikt om het argument op te tellen bij de huidige waarde in de cel.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[+^n_{ns}]$	&	\AxiomC{$\langle $+$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]+n, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline
%\end{table}

De $+_{ns}$ regel wordt gebruikt om een waarde van de stack te poppen en op te tellen bij de huidige waarde in de cel.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{l c r}

$[+_{ns}]$	&	\AxiomC{$\langle $+$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] + \theta[0], \rho, \theta[1...], O)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt $

\end{tabular}
\newline
\begin{tabular}[h]{l c r}

$[+_{ns}]$	&	\AxiomC{$\langle $+$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \|$"Stack is empty"$)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == ff $

\end{tabular}
\newline

De $-^n_{ns}$ regel wordt gebruikt om een het argument af te trekken van de huidige waarde in de cel.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[-^n_{ns}]$	&	\AxiomC{$\langle $-$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] -n, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline
%\end{table}

%\begin{prooftree}
%	\AxiomC{$\langle $-$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] -n, \rho, \theta, O)$}
%\end{prooftree}

De $-_{ns}$ regel wordt gebruikt om een waarde van de stack te poppen en af te trekken van de huidige waarde in de cel.
\newline
\newline
\begin{tabular}[h]{l c r}

$[-_{ns}]$	&	\AxiomC{$\langle $-$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] - \theta[0], \rho, \theta[1...], O)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt $

\end{tabular}
\newline
\begin{tabular}[h]{l c r}

$[-_{ns}]$	&	\AxiomC{$\langle $-$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| $"Stack is empty"$)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt $

\end{tabular}
\newline

%\begin{prooftree}
%	\AxiomC{$\langle $-$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] - \theta[0], \rho, \theta[1...], O)$}
%\end{prooftree}
De $*^n_{ns}$ regel wordt gebruikt om de huidige waarde in de cel te vermenigvuldigen met het argument.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[*^n_{ns}]$	&	\AxiomC{$\langle $*$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] * n, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline

%\begin{prooftree}
%	\AxiomC{$\langle $*$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] * n, \rho, \theta, O)$}
%\end{prooftree}
De $*_{ns}$ regel wordt gebruikt om een waarde van de stack te poppen en de huidige waarde in de cel hiermee te vermenigvuldigen.
\newline
\newline
\begin{tabular}[h]{l c r}

$[*_{ns}]$	&	\AxiomC{$\langle $*$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]*\theta[0], \rho, \theta[1...], O)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt $

\end{tabular}
\newline
\begin{tabular}[h]{l c r}

$[*_{ns}]$	&	\AxiomC{$\langle $*$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| $"Stack is empty"$)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == ff $

\end{tabular}
\newline
%\begin{prooftree}
%	\AxiomC{$\langle $*$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]*\theta[0), \rho, \theta[1...], O)$}
%\end{prooftree}

De $/^n_{ns}$ regel wordt gebruikt om de huidige waarde in de cel te delen met het argument.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[/^n_{ns}]$	&	\AxiomC{$\langle $/$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]/n, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline
%\end{table}
%\begin{prooftree}
%	\AxiomC{$\langle $/$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]/n, \rho, \theta, O)$}
%\end{prooftree}

De $/_{ns}$ regel wordt gebruikt om een waarde van de stack te poppen en de huidige waarde in de cel hiermee te delen.
\newline
\newline
\begin{tabular}[h]{l c r}

$[/_{ns}]$	&	\AxiomC{$\langle $/$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]/\theta[0], \rho, \theta[1...], O)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt $

\end{tabular}
\newline
\begin{tabular}[h]{l c r}

$[/_{ns}]$	&	\AxiomC{$\langle $/$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| $"Stack is empty"$)$}
		  \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == ff $

\end{tabular}
\newline
%\begin{prooftree}
%	\AxiomC{$\langle $/$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma]/\theta[0], \rho, \theta[1...], O)$}
%\end{prooftree}

De $\%^n_{ns}$ regel wordt gebruikt om de huidige waarde in de cel te vervangen met zichzelf modulus het argument.
\newline
\newline
%\begin{table}[h]
\begin{tabular}[h]{c c}

$[\%^n_{ns}]$	&	\AxiomC{$\langle $\%$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] \%n, \rho, \theta, O)$}
				\DisplayProof

\end{tabular}
\newline
%\end{table}
%\begin{prooftree}
%	\AxiomC{$\langle $\%$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] \%n, \rho, \theta, O)$}
%\end{prooftree}

De $\%_{ns}$ regel wordt gebruikt om de huidige waarde in de cel te vervangen met zichzelf modulus een waar de die van de stack wordt gepopt.
\newline
\newline
\begin{tabular}[h]{l c r}

$[\%_{ns}]$	&	\AxiomC{$\langle $\%$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] \% \theta[0], \rho, \theta[1...], O)$}
		   \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == tt $

\end{tabular}
\newline
\begin{tabular}[h]{l c r}

$[\%_{ns}]$	&	\AxiomC{$\langle $\%$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| $"Stack is empty"$)$}
		   \DisplayProof & $if {\cal B} _{[\theta[0] \neq undefined]s} == ff $

\end{tabular}
\newline
%\begin{prooftree}
%	\AxiomC{$\langle $\%$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV[\sigma] \mapsto AV[\sigma] \% \theta[0], \rho, \theta[1...], O)$}
%\end{prooftree}

% Standard output regels
%Vanaf hier hebben we een extra state-element, een standaard output stream \(O\) nodig.

\subsection{Standard output}
In de referentie-implementatie van Foo hebben we ontdekt dat de standard output gebufferd word, zoals normaal in Unix-programma's.
Dit maakt het gedrag van operaties op de standard output wat onvoorspelbaar, zeker in combinatie met loopen en het pauzeren van het programma.
Bij het printen van strings in een loop bijvoorbeeld is het effect dat de standard output wordt gebuffered totdat het programma afgelopen is, of de buffergrootte van de standard output wordt overschreven.
Om bij een operatie op de standard output (ook bij loopen) direct resultaat te kunnen zien is het nodig het standard output buffer te `flushen' nadat er output gegenereerd is.
We hebben voor ons onderzoek deze toevoeging in de referentieimplementatie gemaakt, en zijn van plan dit ook voor te leggen aan ``Feky'', de auteur van Foo.

De $stdout_{ns}$ regel wordt gebruikt om een letterlijke string op de standard output te zetten door middel van concatenatie.
\newline
\newline
\begin{tabular}[h]{c c}

$[stdout_{ns}]$	&	\AxiomC{$\langle $"$<str>$"$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| <str>)$}
				\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $"$<str>$"$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| <str>)$}
%\end{prooftree}

De $print^c_{ns}$ regel print de huidige waarde uit de array als letterlijk 'character' naar de standard output.
\newline
\newline
\begin{tabular}[h]{c c}

$[print^c_{ns}]$	&	\AxiomC{$\langle $\$c$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| AV[\sigma])$}
				\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $\$c$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| AV[\sigma])$}
%\end{prooftree}

De $print^{cn}_{ns}$ regel print het argument als 'character' naar de standard output.
\newline
\newline
\begin{tabular}[h]{c c}

$[print^{cn}_{ns}]$	&	\AxiomC{$\langle $\$c$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| n)$}
				\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $\$c$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| n)$}
%\end{prooftree}

De $print^i_{ns}$ regel print de ASCII-represenatie van de huidige waarde uit de array naar de standard output.
\newline
\newline
\begin{tabular}[h]{c c}

$[print^i_{ns}]$	&	\AxiomC{$\langle $\$i$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(AV[\sigma]))$}
				\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $\$i$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(AV[\sigma]))$}
%\end{prooftree}

De $print^{in}_{ns}$ regel print de ASCII-represenatie van het argument naar de standard output.
\newline
\newline
\begin{tabular}[h]{c c}

$[print^{in}_{ns}]$	&	\AxiomC{$\langle $\$i$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(n))$}
				\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $\$i$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(n))$}
%\end{prooftree}

De $print^h_{ns}$ regel print in ASCII de hexadecimale represenatie van de huidige waarde uit de array naar de standard output.
\newline
\newline
\begin{tabular}[h]{c c}

$[print^h_{ns}]$	&	\AxiomC{$\langle $\$h$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(hex(AV[\sigma])))$}
				\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $\$h$, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(hex(AV[\sigma])))$}
%\end{prooftree}

De $print^{hn}_{ns}$ regel print in ASCII de hexadecimale represenatie van het argument naar de standard output.
\newline
\newline
\begin{tabular}[h]{c c}

$[print^{hn}_{ns}]$	&	\AxiomC{$\langle $\$h$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(hex(n)))$}
					\DisplayProof

\end{tabular}
\newline
%\begin{prooftree}
%\AxiomC{$\langle $\$h$n, (\sigma, AV, \rho, \theta, O) \rangle \rightarrow  (\sigma, AV, \rho, \theta, O \| ascii(hex(n)))$}
%\end{prooftree}


\section{Analyse van de Foo semantiek}
In dit hoofdstuk zullen we aan de hand van een aantal case studies, de bovenstaande semantiekregels toepassen.



%\section{Structurele operationale semantiek van Foo}

%\bibliographystyle{plain} % amsalpha
%\bibliography{}

\end{document}
